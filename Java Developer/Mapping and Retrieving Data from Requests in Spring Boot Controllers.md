[![spring-boot-logo.png](https://i.postimg.cc/8kd0mzMk/spring-boot-logo-2.png)](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html)

## Урок: Мэппинг и получение данных из запросов в контроллерах Spring Boot

### 1. Вступление

**Контроллеры** — это ключевой элемент любой веб-приложения, построенной на базе Spring Boot. Они являются интерфейсом между клиентом и сервером и управляют передачей данных через HTTP-запросы. Умение настраивать и управлять контроллерами критически важно для разработчиков веб-приложений, которые используют Spring Boot.

**Мэппинг** в контроллерах Spring Boot — это процесс связывания (ассоциации) HTTP-запросов с определёнными методами контроллера, которые будут обрабатывать эти запросы.

Мэппинг позволяет разработчикам настроить маршрутизацию запросов (определить, какой метод контроллера будет вызван в ответ на определённый запрос) и указать, какие типы запросов (GET, POST, PUT, DELETE и т.д.) и URL-адреса (пути) связаны с этими методами.

В Spring Boot мэппинг осуществляется с помощью аннотаций, которые указывают, какой HTTP-запрос должен быть направлен к какому методу. 

**Аннотации** в Spring Boot — это специальные метаданные, которые отмечены символом `@`, и которые используются для предоставления дополнительной информации о классах, методах и параметров методов. 

На этом уроке мы разберем, как настраивать мэппинг HTTP-запросов в контроллерах Spring Boot, а также как извлекать и обрабатывать данные, которые приходят с этими запросами. Эти знания помогут создавать более гибкие и эффективные приложения, работающие по принципу REST.

### 2. Основная часть урока

#### 2.1. Что такое контроллер в Spring Boot?

Контроллер — это Java-класс, который управляет поступающими HTTP-запросами и отвечает за передачу данных обратно пользователю или клиенту. Spring Boot использует аннотации для того, чтобы связать запросы с методами контроллеров. Основной аннотацией является `@RestController`, которая указывает Spring, что данный класс будет обрабатывать HTTP-запросы.

```java
@RestController
public class MyController {
    // Методы обработки запросов
}
```

#### 2.2. Мэппинг запросов

Мэппинг (сопоставление) запросов — это процесс связывания HTTP-запроса с конкретным методом контроллера. Spring Boot предлагает несколько аннотаций для мэппинга:

- `@RequestMapping` — универсальная аннотация для обработки любого HTTP-запроса (GET, POST, PUT, DELETE).
- `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` — специализированные аннотации для обработки конкретных типов запросов.

Аннотация @RequestMapping используется для мэппинга HTTP-запросов к методам контроллеров. Это универсальная аннотация, которая позволяет настраивать мэппинг запросов для любых HTTP-методов, таких как GET, POST, PUT, DELETE и других

`@RequestMapping` можно применять как на уровне класса, так и на уровне метода.

Применение `@RequestMapping` на уровне класса задает базовый URL-адрес (или корневой URL) для всех методов контроллера.

**Пример:**

```java
@RestController
@RequestMapping("/api")
public class MyController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello, World!";
    }
}
```

В этом примере метод `hello()` обрабатывает GET-запрос по адресу `/api/hello`.

В примере аннотация @RequestMapping на уровне класса задает базовый путь для всех методов в этом контроллере, поэтому все методы в этом контроллере будут обрабатывать запросы, которые начинаются с `/api`.

На уровне метода `@RequestMapping` задает точный URL-адрес и HTTP-метод для конкретного метода в контроллере.

**Пример:**

```java
@RestController
@RequestMapping("/api")  // Базовый путь для всех методов в этом классе
public class MyController {

    @RequestMapping(value = "/hello", method = RequestMethod.GET)
    public String sayHello() {
        return "Hello, World!";
    }

    @RequestMapping(value = "/goodbye", method = RequestMethod.POST)
    public String sayGoodbye() {
        return "Goodbye, World!";
    }
}
```

В этом примере на уровне класса аннотация @RequestMapping("/api") указывает, что все методы этого контроллера будут иметь базовый путь `/api`.  

Метод sayHello() будет обрабатывать GET-запросы на путь `/api/hello`.  

Метод sayGoodbye() будет обрабатывать POST-запросы на путь `/api/goodbye`.  

Аннотация `@RequestMapping` предоставляет множество атрибутов, которые позволяют настроить мэппинг HTTP-запросов к методам контроллера. Эти атрибуты помогают точнее контролировать, какие запросы обрабатываются каким методом, и как эти запросы должны быть обработаны.

Рассмотрим основные атрибуты аннотации `@RequestMapping`:

#### 1) Атрибут **`value`** или **`path`** определяет URL-адреса (или пути), к которым привязан метод контроллера.

**Пример:**  

  ```java
  @RequestMapping(value = "/api/greet", method = RequestMethod.GET)
  public String greet() {
      return "Hello!";
  }
  ```
  Здесь `value = "/api/greet"` задает путь `/api/greet`, который будет обрабатываться методом `greet()`.

#### 2) Атрибут **`method`** указывает HTTP-методы (GET, POST, PUT, DELETE и т.д.), для которых этот метод контроллера должен быть вызван.

**Пример:**  

  ```java
  @RequestMapping(value = "/api/create", method = RequestMethod.POST)
  public String create() {
      return "Resource created!";
  }
  ```
  Здесь `method = RequestMethod.POST` указывает, что метод `create()` обрабатывает только POST-запросы.

#### 3) Атрибут **`params`** определяет параметры запроса, которые должны присутствовать в запросе для того, чтобы метод был вызван. Можно указывать конкретные значения параметров.

**Пример:**  

  ```java
  @RequestMapping(value = "/api/search", params = "query")
  public String search(@RequestParam String query) {
      return "Searching for: " + query;
  }
  ```
  Здесь `params = "query"` указывает, что метод будет вызван только если параметр `query` присутствует в запросе, например, `/api/search?query=spring`.

#### 4) Атрибут **`headers`** определяет заголовки HTTP-запроса, которые должны присутствовать для того, чтобы метод был вызван. Можно указывать конкретные значения заголовков.

**Пример:**  

  ```java
  @RequestMapping(value = "/api/info", headers = "X-Requested-With=XMLHttpRequest")
  public String info() {
      return "Information from AJAX request";
  }
  ```
  Здесь `headers = "X-Requested-With=XMLHttpRequest"` указывает, что метод будет вызван только если заголовок `X-Requested-With` имеет значение `XMLHttpRequest`.

#### 5) Атрибут **`produces`** определяет типы контента (MIME-типы), которые метод может возвращать. Используется для указания формата ответа.

**Пример:**

  ```java
  @RequestMapping(value = "/api/json", produces = "application/json")
  public String getJson() {
      return "{\"message\":\"Hello, JSON!\"}";
  }
  ```
  Здесь `produces = "application/json"` указывает, что метод возвращает ответ в формате JSON.

#### 6) Атрибут **`consumes`** определяет типы контента (MIME-типы), которые метод может принимать в запросе. Используется для указания формата входных данных.

**Пример:**
  ```java
  @RequestMapping(value = "/api/upload", method = RequestMethod.POST, consumes = "multipart/form-data")
  public String upload(@RequestParam("file") MultipartFile file) {
      return "File uploaded successfully!";
  }
  ```
  Здесь `consumes = "multipart/form-data"` указывает, что метод принимает запросы с типом контента `multipart/form-data`, который обычно используется для загрузки файлов.

В контроллере, могут использоваться сразу несколько перечисленных атрибутов аннотации `@RequestMapping`.

**Пример:**

```java
@RestController
@RequestMapping("/api")
public class MyController {

    @RequestMapping(
        value = "/items",
        method = RequestMethod.GET,
        params = "category",
        headers = "Accept=application/json",
        produces = "application/json"
    )
    public String getItems(@RequestParam String category) {
        return "{\"category\":\"" + category + "\",\"items\":[\"Item1\",\"Item2\"]}";
    }

    @RequestMapping(
        value = "/items",
        method = RequestMethod.POST,
        consumes = "application/json"
    )
    public String createItem(@RequestBody String newItem) {
        return "Item created: " + newItem;
    }
}
```

**В этом примере:**
- **Метод `getItems`**:
  - Обрабатывает GET-запросы на путь `/api/items`.
  - Запрос должен содержать параметр `category`.
  - Запрос должен иметь заголовок `Accept` со значением `application/json`.
  - Возвращает ответ в формате JSON.

- **Метод `createItem`**:
  - Обрабатывает POST-запросы на путь `/api/items`.
  - Принимает тело запроса в формате JSON (`consumes = "application/json"`).

Эти атрибуты позволяют гибко настраивать обработку запросов и отвечать на различные сценарии использования в веб-приложении.

#### 2.3. Получение данных из запросов

Важной частью работы с контроллерами является извлечение данных из HTTP-запросов. Рассмотрим основные аннотации для этого:

##### 2.3.1. @RequestParam

Используется для извлечения данных из параметров запроса (query parameters). Это обычно те данные, которые идут после символа `?` в URL.

```java
@GetMapping("/greet")
public String greet(@RequestParam(name = "name", defaultValue = "Guest") String name) {
    return "Hello, " + name;
}
```

**Пример запроса:** `GET /greet?name=John`  
**Результат:** `"Hello, John"`

##### 2.3.2. @PathVariable

Эта аннотация используется для извлечения данных из переменных пути (path variables). Они являются частью самого URL.

```java
@GetMapping("/user/{id}")
public String getUserById(@PathVariable("id") Long userId) {
    return "User ID: " + userId;
}
```

**Пример запроса:** `GET /user/123`  
**Результат:** `"User ID: 123"`

##### 2.3.3. @RequestBody

Используется для получения данных из тела запроса (например, JSON) и автоматической их конвертации в объекты Java.

```java
@PostMapping("/users")
public User createUser(@RequestBody User user) {
    return user;
}
```

**Пример запроса:** `POST /users` с телом запроса:

```json
{
  "id": 1,
  "firstName": "John",
  "lastName": "Doe",
  "age": 25
}
```

**Результат:** объект `User` будет передан методу `createUser`.

##### 2.3.4. @RequestHeader

Эта аннотация используется для извлечения данных из заголовков HTTP-запроса.

```java
@GetMapping("/header")
public String getHeader(@RequestHeader("User-Agent") String userAgent) {
    return "User-Agent: " + userAgent;
}
```

**Пример запроса:**  
**Результат:** Вывод заголовка `User-Agent`.



#### 2.4. Практические задания

1. **Задание 1**: Создайте контроллер с методом, который принимает GET-запрос и возвращает персонализированное приветствие в зависимости от параметра `name`.  
   
   **Подсказка:** Используйте `@RequestParam`.

2. **Задание 2**: Создайте контроллер, который принимает POST-запрос с данными пользователя в формате JSON и возвращает его возраст.  
   
   **Подсказка:** Используйте `@RequestBody`.

3. **Задание 3**: Реализуйте метод, который будет принимать переменную пути (например, ID пользователя) и возвращать это значение.  
   
   **Подсказка:** Используйте `@PathVariable`.

### 3. Выводы и подведение итогов урока

Сегодня мы изучили ключевые аспекты работы с контроллерами в Spring Boot. Вы узнали, как настраивать мэппинг запросов с помощью аннотаций, а также как извлекать данные из различных частей HTTP-запросов: параметров, переменных пути, тела запроса и заголовков. 

Основные тезисы темы:

`1)` **Контроллеры в Spring Boot** являются ключевыми компонентами, обрабатывающими HTTP-запросы и формирующими ответы. Аннотация `@RestController` указывает, что класс является контроллером и обрабатывает запросы.

`2)` **Мэппинг HTTP-запросов** — это процесс связывания HTTP-запросов с методами контроллера. В Spring Boot используются аннотации `@RequestMapping` для универсального мэппинга, а также специализированные аннотации `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` для конкретных типов запросов.

`3)` **Извлечение данных из запросов** возможно с использованием аннотаций:
   - **@RequestParam**: Извлекает данные из параметров запроса (query parameters), например, `GET /greet?name=John` использует параметр `name`.
   - **@PathVariable**: Извлекает данные из переменных пути, например, `GET /user/123` использует `id` как часть пути.
   - **@RequestBody**: Извлекает данные из тела запроса, часто в формате JSON, и автоматически конвертирует их в объекты Java.
   - **@RequestHeader**: Позволяет получать значения заголовков HTTP-запроса, таких как `User-Agent`.

`4)` **Гибкость и эффективность**: Знание методов мэппинга и извлечения данных позволяет разработчикам создавать гибкие и эффективные веб-приложения с использованием Spring Boot, реализующие принципы REST и легко обрабатывающие различные типы запросов и данных.

### 4. Контрольное тестирование

Тестирование помогает закрепить знания, полученные на уроке. Проходя тесты, вы можете увидеть, насколько хорошо усвоили материал, выявить пробелы в понимании и скорректировать свое обучение. Это важный шаг к закреплению навыков и подготовке к более сложным задачам.

Этот тест построен на базе Google Forms и поможет проверить ваше понимание ключевых аспектов работы с контроллерами в Spring Boot.

#### Инструкция по прохождению теста:

1. Перед началом теста вам будет предложено ввести свой адрес электронной почты. Убедитесь, что вы указали правильный и действующий адрес, так как результаты теста будут отправлены на указанный адрес.

2. Тест состоит из **20 вопросов**. Каждый вопрос относится к материалу, который был представлен в уроке.

3. У каждого вопроса есть **три варианта ответа**. Только один из них является правильным.

4. Для каждого вопроса выберите **один правильный ответ**. Пожалуйста, убедитесь, что вы выбрали один ответ, прежде чем переходить к следующему вопросу.

5. Результаты теста будут автоматически направлены в почту, указанную при регистрации.

#### Удачи! 

[Пройти тест](https://forms.gle/ThAcBTWHqr1hAUYY7)

--- 

**На следующем уроке** мы углубимся в создание REST API и разберем, как обрабатывать различные HTTP-методы и статус-коды ответов.
